F94041026 醫工108 徐慶航

標頭檔介紹
#include <iomanip> :矩陣排版。	
#include <time.h>  :搭配srand(time(NULL));可以讓每次的rand()有不一樣的結果。

變數介紹
int result1[15][15]; //第一小題的result矩陣
int result2[39][19]; //第二小題的result矩陣
int k;int m;		 //k和m為提供數字的變數
int imove[8] = { -1, 0, 1, 1, 1, 0, -1, -1 };
int jmove[8] = { 1, 1, 1, 0, -1, -1, -1, 0 };
int position1[2] = { 10,10 }; //第一小題的當前(x,y)
int position2[2] = { 1,1 };   //第二小題的當前(x,y)
int check1(int result1[15][15])   //判斷第一小題是否結束
int count1 = 0; //第一小題全體步數初始化
int count2 = 0; //第二小題全部步數初始化

Function介紹
int check1()//判斷第一小題是否結束，裡面會進行for的運算來看全部的座標都有被走過一次。
int check2()//判斷第二小題是否結束，同上。

int main()介紹
程式的結構主要是如下:
先把起始點步數設為1 => 初始化全體步數 => 設暫存變數position11來存移動前的座標 => while迴圈，條件是呼叫function來看是否要繼續做 =>
迴圈內主要是讓當前的座標進行移動再進行判定。如果移動完後超出範圍即白走一步，把暫存變數的值存回當前的座標。如果移動完後並沒有超出座標
，就讓新的座標位置的計數器+1並且全體步數加1。

P.S. 127行後的註解掉的為原本會錯意的程式碼，是直接會對左上角邊界、右上角邊界、右下角邊界、右上角邊界、左邊邊界、上邊邊界、右邊邊界、下邊邊界
等八種非典型位置進行直接的方向限制，能夠確保每一步走出去的一定都在界線以內的，不過與題意步和，因為題目的前題假設就是蟑螂各方向機率一樣。依照
我的寫法會變成各方向機率不見得一樣。
